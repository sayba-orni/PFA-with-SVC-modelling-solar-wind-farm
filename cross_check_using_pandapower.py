# -*- coding: utf-8 -*-
"""cross_check_using_pandapower.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NZErFajlu9jJyH0kPFQMMur6jcHOFDTZ
"""

# Install & import
!pip -q install pandapower

import pandapower as pp
import numpy as np

# Build the 6-bus network (split line 3-4)
net = pp.create_empty_network(sn_mva=100.0)

# Buses (voltage level is arbitrary here)
b1 = pp.create_bus(net, vn_kv=110., name="1")  # slack
b2 = pp.create_bus(net, vn_kv=110., name="2")
b3 = pp.create_bus(net, vn_kv=110., name="3")
b4 = pp.create_bus(net, vn_kv=110., name="4")
b5 = pp.create_bus(net, vn_kv=110., name="5")
b6 = pp.create_bus(net, vn_kv=110., name="6_mid_3-4")  # midpoint

# Loads (MW, MVAr)
pp.create_load(net, b2, p_mw=20.0, q_mvar=10.0)
pp.create_load(net, b3, p_mw=45.0, q_mvar=15.0)
pp.create_load(net, b4, p_mw=40.0, q_mvar=5.0)
pp.create_load(net, b5, p_mw=60.0, q_mvar=10.0)

# Slack at bus 1 with |V|=1.06 pu
pp.create_ext_grid(net, bus=b1, vm_pu=1.06, name="Slack@1")

# Generator at bus 2 as PQ (use sgen so bus 2 stays PQ)
pp.create_sgen(net, bus=b2, p_mw=40.0, q_mvar=30.0, name="Gen@2")

# create series-only "impedance" (no line charging here)
def add_imp_series(net, f, t, r_pu, x_pu, name):
    pp.create_impedance(net, from_bus=f, to_bus=t,
                        rft_pu=r_pu, xft_pu=x_pu,
                        rtf_pu=r_pu, xtf_pu=x_pu,
                        sn_mva=net.sn_mva, name=name)

# add per-end shunt susceptance B_end as a shunt element
# In pandapower shunt: negative q_mvar => capacitive injection.
def add_end_shunt(net, bus, B_end_pu, name):
    q_mvar = -B_end_pu * net.sn_mva   # Q = -B * Sbase at 1 pu
    pp.create_shunt(net, bus=bus, q_mvar=q_mvar, p_mw=0.0, name=name)

# Original branches (per unit on 100 MVA)
# r,x and per-end B (the same B values used in MATLAB Y)
B12=0.03; B13=0.025; B23=0.02; B24=0.02; B25=0.015; B34=0.01; B45=0.025

# Series parts (no b_pu here)
add_imp_series(net, b1, b2, 0.02, 0.06, "1-2")
add_imp_series(net, b1, b3, 0.08, 0.24, "1-3")
add_imp_series(net, b2, b3, 0.06, 0.25, "2-3")
add_imp_series(net, b2, b4, 0.06, 0.18, "2-4")
add_imp_series(net, b2, b5, 0.04, 0.12, "2-5")

# Split 3-4 into two halves: (r/2, x/2)
add_imp_series(net, b3, b6, 0.005, 0.015, "3-6")
add_imp_series(net, b6, b4, 0.005, 0.015, "6-4")

add_imp_series(net, b4, b5, 0.08, 0.24, "4-5")

# Per-end shunts (π model). For 3-4, redistribute B34/2 at each of the four ends
# 1-2 ends
add_end_shunt(net, b1, B12, "B12@bus1")
add_end_shunt(net, b2, B12, "B12@bus2")
# 1-3 ends
add_end_shunt(net, b1, B13, "B13@bus1")
add_end_shunt(net, b3, B13, "B13@bus3")
# 2-3 ends
add_end_shunt(net, b2, B23, "B23@bus2")
add_end_shunt(net, b3, B23, "B23@bus3")
# 2-4 ends
add_end_shunt(net, b2, B24, "B24@bus2")
add_end_shunt(net, b4, B24, "B24@bus4")
# 2-5 ends
add_end_shunt(net, b2, B25, "B25@bus2")
add_end_shunt(net, b5, B25, "B25@bus5")
# 3-4 split ends: each half-line end gets B34/2 = 0.005
add_end_shunt(net, b3, B34/2, "B34half@bus3")
add_end_shunt(net, b6, B34/2, "B34half@bus6_from36")
add_end_shunt(net, b6, B34/2, "B34half@bus6_from64")
add_end_shunt(net, b4, B34/2, "B34half@bus4")
# 4-5 ends
add_end_shunt(net, b4, B45, "B45@bus4")
add_end_shunt(net, b5, B45, "B45@bus5")

# SVC at bus 6
# MATLAB result: B_svc = -0.22659 pu => Qsvc = -V^2 * B * Sbase = +22.659 MVAr injection
Qsvc_matlab = +22.659
pp.create_shunt(net, bus=b6, q_mvar=-Qsvc_matlab, p_mw=0.0, name="SVC@6")

# Case A: fixed SVC from MATLAB)
pp.runpp(net, algorithm="nr", calculate_voltage_angles=True)

print("=== Case A: Using MATLAB B_svc (Q_shunt = -22.659 MVAr) ===")
for i, bus in enumerate(net.bus.index, start=1):
    vm = net.res_bus.vm_pu.at[bus]
    va = net.res_bus.va_degree.at[bus]
    print(f"Bus {i}: |V|={vm:.5f}, angle={va:+.4f} deg")
print(f"Slack injections: P={net.res_ext_grid.p_mw.sum():.4f} MW, Q={net.res_ext_grid.q_mvar.sum():.4f} MVAr")

#  solve for Q_svc to enforce |V6|=1.000 (secant)
def solve_q_for_v6(v_target=1.0, q0=-15.0, q1=-30.0, tol=1e-6, itmax=20):
    sh_idx = net.shunt.query("name == 'SVC@6'").index[0]
    def v6_err(qmvar):
        net.shunt.at[sh_idx, "q_mvar"] = qmvar
        pp.runpp(net, algorithm="nr", calculate_voltage_angles=True)
        return net.res_bus.vm_pu.at[b6] - v_target

    f0 = v6_err(q0)
    f1 = v6_err(q1)
    for _ in range(itmax):
        if abs(f1 - f0) < 1e-12:
            break
        q2 = q1 - f1 * (q1 - q0) / (f1 - f0)
        f2 = v6_err(q2)
        if abs(f2) < tol:
            return q2
        q0, f0 = q1, f1
        q1, f1 = q2, f2
    return q1

q_star = solve_q_for_v6(v_target=1.0, q0=-15.0, q1=-30.0)
pp.runpp(net, algorithm="nr", calculate_voltage_angles=True)

print("\n=== Case B: Solved shunt Q so that |V6| ≈ 1.000 pu ===")
print(f"Solved Q_shunt at bus 6 = {q_star:.5f} MVAr (negative => capacitive injection)")
for i, bus in enumerate(net.bus.index, start=1):
    vm = net.res_bus.vm_pu.at[bus]
    va = net.res_bus.va_degree.at[bus]
    print(f"Bus {i}: |V|={vm:.5f}, angle={va:+.4f} deg")
print(f"Slack injections: P={net.res_ext_grid.p_mw.sum():.4f} MW, Q={net.res_ext_grid.q_mvar.sum():.4f} MVAr")